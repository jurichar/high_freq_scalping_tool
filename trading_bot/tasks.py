"""
tasks.py

Module for orchestrating the key operations of the trading bot, such as data collection, 
processing, and backtesting.

Functions:
- collect_and_save_data: Collects data for a specific period and saves it.
- process_data: Cleans data and adds technical indicators.
- run_backtest: Runs a backtest using historical data and displays performance metrics.
"""

import logging
import pandas as pd
from trading_bot.data_collector import get_data_for_period
from .data_processor import clean_data, add_technical_indicators, save_processed_data
from .strategy import generate_signals
from .executor import TradingExecutor
from datetime import datetime


def collect_and_save_data(
    ticker: str, start_date: str, end_date: str, interval: str = "1d"
):
    """
    Collect stock data for a specified period and save it to CSV.

    Args:
        ticker (str): The stock ticker symbol.
        start_date (str): The start date (YYYY-MM-DD).
        end_date (str): The end date (YYYY-MM-DD).
        interval (str): The data interval (e.g., '1d', '1h').

    Returns:
        pd.DataFrame: The collected stock data.
    """
    logging.info(f"Collecting data for {ticker} from {start_date} to {end_date}...")
    data = get_data_for_period(
        ticker, start_date, end_date, interval=interval, save_to_csv=True
    )
    logging.info(f"Data for {ticker} collected and saved.")
    return data


def process_data(ticker: str, data: pd.DataFrame, period: str = "1y"):
    """
    Process stock data by cleaning and adding technical indicators, then save it.

    Args:
        ticker (str): The stock ticker symbol.
        data (pd.DataFrame): The stock data to process.
        period (str): The period of the data.

    Returns:
        pd.DataFrame: The processed stock data with technical indicators.
    """
    logging.info(f"Processing data for {ticker}...")
    data = clean_data(data)
    data = add_technical_indicators(data)
    save_processed_data(data, ticker, period)
    logging.info(f"Data for {ticker} processed and saved.")
    return data


def run_backtest(
    ticker: str,
    start_date: str,
    end_date: str,
    compare_start: str,
    compare_end: str,
    initial_cash: float = 10000,
):
    """
    Run a backtest by comparing the signals generated by the strategy with actual stock data.

    Args:
        ticker (str): The stock ticker symbol.
        start_date (str): The start date for the training period.
        end_date (str): The end date for the training period.
        compare_start (str): The start date for the comparison period.
        compare_end (str): The end date for the comparison period.
        initial_cash (float): The initial cash for the trading simulation.

    Returns:
        None
    """
    compare_start = pd.Timestamp(compare_start).tz_localize(None)
    compare_end = pd.Timestamp(compare_end).tz_localize(None)
    end_date = pd.Timestamp(end_date).tz_localize(None)

    final_end_date = max(end_date, compare_end)
    data = collect_and_save_data(ticker, start_date, final_end_date)
    processed_data = process_data(ticker, data)

    logging.info("Generating trading signals for backtest...")
    signals = generate_signals(processed_data)
    signals.index = pd.to_datetime(signals.index).tz_localize(None)

    logging.info(
        f"Starting backtest for {ticker} from {compare_start} to {compare_end}..."
    )
    executor = TradingExecutor(initial_cash=initial_cash)

    for index, row in signals.iterrows():
        if compare_start <= index <= compare_end:
            executor.execute_orders(pd.DataFrame([row]))

    final_price = processed_data.get(compare_end, processed_data.iloc[-1])["Close"]
    executor.display_portfolio(final_price)

    logging.info(
        f"Backtest for {ticker} completed. Final portfolio value: ${executor.cash + executor.stock_balance * final_price:.2f}"
    )


# Example usage
if __name__ == "__main__":
    import doctest

    doctest.testmod()

    run_backtest(
        ticker="MSFT",
        start_date="2020-01-01",
        end_date="2020-03-31",
        compare_start="2020-04-01",
        compare_end="2020-06-30",
    )
